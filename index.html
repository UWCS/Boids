<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Visualization</title>
    
    <!-- p5.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/prism.min.js"></script>
    
    <!-- Stylesheets -->
    <link rel="stylesheet" href="/Boids/Stylesheets/visualization.css">
</head>
<body>
    <div class="container">
        <header>
            <h1>BOIDS</h1>
            <p class="subtitle">Simulating agents with p5.js</p>
        </header>

        <div class="content-grid">
            <div class="text-section">
                <h2>What we'll make</h2>
                <p>Boids.</p>
            </div>

            <div class="visualization-section">
                <div id="p5-container"></div>
            </div>
        </div>

        <section class="tutorial-section">
            <h2>Intro to p5</h2>
            <p>p5.js is a JavaScript library that'll let us create interactive programs. 
                It's also fairly easy to add to a website if you want to add it to a project!
            </p>
            
            
            <h3>Getting Started: p5 editor</h3>
            
            <p>We'll be using the p5 editor to write and run our p5 simulations:
                <ul>
                    <li>Go to <a href="https://editor.p5js.org/">https://editor.p5js.org/</a></li>
                    <li>Create an account</li>
                    <li>Create a new sketch</li>
                </ul>
            </p>

            <h3>Basics of p5</h3>
            <p>Here's a basic initial p5 program. </p>
            <pre><code class="language-javascript">function setup() { // this is run once at the start
  createCanvas(400, 400);
  console.log("Start!");
}

function draw() { // this is run every frame
  background(220);
  console.log("Every frame");
}
</code></pre>
            <p>p5.js works by providing two main functions: <code>setup()</code> (run once) and <code>draw()</code> (run continuously, every frame). </p>
            
            <p>Critically, <strong> you can only use p5 library functions inside of these functions. </strong> </p>

            <p>We can see the key difference between <code>setup()</code> and <code>draw()</code> when we look at the following two slightly different programs: </p>
            <pre><code class="language-javascript">function setup() { 
  createCanvas(400, 400);
}

function draw() { 
  background(220); 
  circle(mouseX, mouseY, 40);
}</code></pre>

            <pre><code class="language-javascript">function setup() { 
  createCanvas(400, 400);
  background(220); 
}

function draw() { 
  circle(mouseX, mouseY, 40);
}</code></pre>

            <p>So in the first example, background is called inside of <code>draw()</code> and this covers stuff drawn in the previous frames. </p>

            <h3>Getting Colourful</h3>
            <p>To inject some fun into our dreary lives, we can add some colour! The <code>stroke()</code> function sets the colour of the perimeter of shapes whenever called and <code>fill()</code> does this for the area.</p>

            <pre><code class="language-javascript">function setup() { 
  createCanvas(400, 400);
  background(220); 
  
  stroke("red");
  fill("yellow");
}

function draw() { 
  circle(mouseX, mouseY, 40);
}</code></pre>
        </section>

        <section class="tutorial-section">
            <h2>Creating a boid class: Drawing </h2>
            <p>We'll create a class for our boids. There should be three main parts:
                <ul>
                    <li>The steering behaviour logic</li>
                    <li>Updating the physics</li>
                    <li>Drawing the boid to the screen</li>
                </ul>
            </p>

            <p>For now, let's just focus on drawing the boid to the screen; 
                our visualisation will have boids as triangles and will point in the direction of travel (velocity).
                Since it's just following our mouse, we'll set the velocity to some arbitrary direction. </p>
            
            <h3>Initialiser</h3>
            <p>Note that static variables are just variables that belong to the class rather than a specific instance
                - so editing one changes it for all instances of the class
                (p5 may also warn you about initialising a static variable but it should be fine).
            </p>
            
            <pre><code class="language-javascript">class Boid {
  static size = 20;

  constructor(){
    this.position = createVector(0,0);
    this.velocity = createVector(1,0);
    this.acceleration = createVector(0,0);
  }
}</code></pre>

            <p>If you want to understand how vectors in p5 work better, you can check the docs: <a href="https://p5js.org/reference/p5/p5.Vector/">https://p5js.org/reference/p5/p5.Vector/</a></p>

            <h3>Drawing a triangle</h3>

            <p><strong>(If you're not interested in the maths, then feel free to just copy the triangle drawing code at the link at the bottom)</strong></p>

            <p>To draw a <a href="https://p5js.org/reference/p5/triangle/">triangle</a> in p5, we have to provide the coordinates to the points of the triangle.</p>

            <p>One point (p1) can just be the boid's position, but the other two points should be drawn so that the triangle points
                in the direction of the boid's velocity.
            </p>

            <p>We can do this by creating difference vectors that'll represent the sides of the triangle - one side being between p1 and p2, and the other being between p2 and p3.
                We generate these difference vectors by just rotating the velocity and scaling it to be the size of the length of our boid.
            </p>
            
            <p>We will create a <code>drawBoid()</code> method inside of the Boid class to do this: </p>
            <pre><code class="language-javascript">
drawBoid(){
    let heading = this.velocity;
    
    let dp2 = heading.copy();
    
    dp2.rotate(170);
    dp2.setMag(Boid.size);
    
    let dp3 = heading.copy();
    
    dp3.rotate(190);
    dp3.setMag(Boid.size);
    
    // finish the code to add dp2, dp3 to form p2, p3
    // call the triangle method to draw our triangle, now that we know p1 (this.position), p2, p3
  }
    </code>
</pre>
            <p>Note that we are using degrees inside of the <code>rotate()</code> method - 
            for this to work, we have to call <code>angleMode(DEGREES)</code> at some point. 
        You should probably put this in <code>setup()</code> somewhere.</p>

            <p><strong>TIP: </strong> When completing this function - 
                keep in mind that if you're creating another vector from an existing one, you should <strong>copy</strong> it.
            Otherwise, editing the new variable will also edit the original vector.
            </p>

            <p>Example of code which changes the original vector:</p>

            <pre><code class="language-javascript">let original = createVector(10, 0);
let another = original.add(createVector(25, 0));
  
console.log("Original: ", original.x, original.y); // What is this?
console.log("Another: ", original.x, original.y);
</code>
</pre>
            <h3>Edge Case: velocity being 0</h3>
            
            <p>There is an edge-case we haven't considered: what will happen when the velocity is (0, 0)? </p>

            <p>To fix this, just add a check at the top - if it is (0, 0), then set heading to (0, 1). </p>

            <h3>Drawing the boid</h3>

            <p>Let's draw our boid at the mouse's position! </p>
            <pre><code class="language-javascript">let mouseBoid; // here so both "setup" and "draw" can see it

function setup() {
  angleMode(DEGREES);
  createCanvas(400, 400);
  
  mouseBoid = new Boid(); // we have to create inside of setup
}

function draw() {
  background(220);
  mouseBoid.position = createVector(mouseX, mouseY);
  mouseBoid.drawBoid();
}</code>
</pre>

            <p><em>Code for this section: <a href="https://editor.p5js.org/RexMortem/sketches/YDrsmVmJE">https://editor.p5js.org/RexMortem/sketches/YDrsmVmJE</a></em></p>
        </section>

        <section class="tutorial-section">
            <h2>Creating a boid class: physics and many boids </h2>
            <p>Let's add acceleration to our boids. To do this, let's create 10 or so boids at the top of our screen
                and give them some downwards acceleration!
            </p>
            
            
            <h3>Adding a physics update method </h3>
            
            <p>As explained in the presentation, you should update velocity and acceleration in a specific way to do it accurately.</p>

            <pre><code class="language-javascript">updatePhysics(){
    this.position.add(0.5 * this.velocity.x * dt, 0.5 * this.velocity.y * dt);
    this.velocity.add(this.acceleration.x * dt, this.acceleration.y * dt);
    this.position.add(0.5 * this.velocity.x * dt, 0.5 * this.velocity.y * dt); 
}</code>
</pre>

            <h3>Creating many boids</h3>
            <p>Instead of just a boid at our mouse's position, we'll need to track many boids - let's use an array. </p>

            <pre><code class="language-javascript">const boids = [];
const nBoids = 20;

function setup() {
  angleMode(DEGREES);
  createCanvas(400, 400);
  
  for(let i = 0; i &lt nBoids; i++){
    let newBoid = new Boid();

    // INSERT code to space the boids out!
    // INSERT code to set acceleration! 

    boids.push(newBoid);
  }
}</code>
</pre>  
        <p>Edit the code to position the boids in appropriate start locations - maybe set position so 
            they're in a straight line at the top?
        </p>

        <p>Also edit the code to set the boid's acceleration. </p>

        <p>And our draw logic is even more straightforward: </p>
        <pre><code class="language-javascript">function draw() {
  background(220);
  
  for(let i = 0; i &lt nBoids; i++){
    boids[i].updatePhysics(deltaTime*0.001); // deltaTime is milliseconds so we scale it
    boids[i].drawBoid();
  }
}</code>
</pre>
        <p><em>Code for this section: <a href="https://editor.p5js.org/RexMortem/sketches/7NjQdeUks">https://editor.p5js.org/RexMortem/sketches/7NjQdeUks</a></em></p>
        </section>

        <section class="tutorial-section">
            <h2>Example Steering Behaviour: Seeking</h2>
            <p>The steering behaviour formula is: <strong>Steering Force = Desired Velocity - Current Velocity</strong>
            
            </p>
            
            <p>So to calculate our force (which is equivalent to acceleration through F=ma given constant mass), 
                we just need to calculate desired velocity and then calculate steering force.
            </p>

            <p>So what is desired velocity for the <strong>Seek</strong> steering behaviour? 
            It's the difference between the target's position and our current position! </p>

            <pre><code class="language-javascript">seek(target){
    // Fill in these variables! Use the sub method for p5 vectors (look it up)
    let desiredVel = 
    let steeringForce = 

    this.acceleration = steeringForce;
  }</code>
</pre>
            
<p>Also make sure to call the <code>seek()</code> function inside of draw - probably before updating physics and drawing!</p>

            <h3>Setting parameters </h3>

            <p>This works, but we might want our boids to move slower or turn slower or so on. 
                We should have parameters for the magnitude of the desired velocity (so how quickly it should move when it achieves desired velocity) 
                and for how quickly the velocity changes (in other words, set magnitude of our force).
            </p>

            <p>Do the following:
                <ul>
                    <li>Add the static variables desiredVelSpeed and forceMag</li>
                    <li>Use <code>setMag()</code> inside of <code>seek()</code> to scale with the static variables</li>
                </ul>
            </p>

            <p>If you want, you can also use <code>limit()</code> instead of <code>setMag()</code> to add limits.</p>

            <p><em>Code for this section: <a href="https://editor.p5js.org/RexMortem/sketches/yhSvBttdX">https://editor.p5js.org/RexMortem/sketches/yhSvBttdX</a></em></p>
        </section>
        
        <section class="tutorial-section">
            <h2>Example Steering Behaviour: Separation </h2>
            <p>A core steering behaviour of traditional boids are that they try to avoid colliding into each other. 
                This is also interesting since it's a group-based steering behaviour.
            </p>

            <p>We will use the same steering force calculation as before, but we will need a more 
                involved calculation to find desired velocity.
            </p>
            
            <h3>Stay Away!</h3>

            <p>To code separation, we want to receive a list of all the boids and do the following:
                <ul>
                    <li>Create a variable for the desired minimum separation</li>
                    <li>Loop through all boids which aren't the current boid</li>
                    <li>If they're closer than the minimum separation, create an away velocity which points away from the other boid</li>
                    <li>Add all these forces from all the other boids together and create an average desired velocity</li>
                    <li>Apply the same steering force calculations as before</li>
                </ul>
            </p>
            
            <p>To test, we want to change the initialisation to create a 2D grid of boids. </p>

            <p><em>Code for this section: <a href="https://editor.p5js.org/RexMortem/sketches/REqnNmpG_">https://editor.p5js.org/RexMortem/sketches/REqnNmpG_</a></em></p>
        </section>

        <section class="tutorial-section">
            <h2>Combining Steering Behaviours</h2>
            <p> Combining steering behaviours is pretty simple - if we amend our steering behaviours
                to return a force, then we can apply weights to the returned forces and add them up.
            </p>

            <p>We then get a function like this: </p>
            
            <pre><code class="language-javascript">steer(target, boids, nBoids){
    let sepForce = this.separate(boids, nBoids);
    let seekForce = this.seek(target);

    this.acceleration = sepForce.add(seekForce);
}</code>
</pre>

        </section>
        
        <section class="tutorial-section">
            <h2>Resources</h2>
            <p>This workshop wouldn't have been possible without the existing work and tutorials on boids.
                If you're interested in learning more, check out the links below:
            </p>
            
            <ul>
                <li><a href="https://natureofcode.com/autonomous-agents/">https://natureofcode.com/autonomous-agents/</a></li>
                <li><a href="https://www.red3d.com/cwr/boids/">https://www.red3d.com/cwr/boids/</a></li>
            </ul>
           
        </section>
    </div>

    <script>
        // Load the basicp5.js sketch
        let sketchInstance;

        function sketch(p) {
            class Boid {
  static size = 20;
  static desiredSeekSpeed = 50;
  static seekForceMag = 25;
  static desiredSepSpeed = 20;
  static sepForceMag = 15;

  constructor(){
    this.position = p.createVector(0,0);
    this.velocity = p.createVector(0,0);
    this.acceleration = p.createVector(0,0);
  }
  
  drawBoid(){
    let heading = this.velocity;
    
    if((heading.x == 0) && (heading.y == 0)){
       heading = p.createVector(0, 1);
    }
    
    let dp2 = heading.copy();
    
    dp2.rotate(170);
    dp2.setMag(Boid.size);
    
    let dp3 = heading.copy();
    
    dp3.rotate(190);
    dp3.setMag(Boid.size);
    
    let p2 = this.position.copy().add(dp2);
    let p3 = this.position.copy().add(dp3);
    
    p.triangle(this.position.x, this.position.y, p2.x, p2.y, p3.x, p3.y);
  }
 
  updatePhysics(dt){
    this.position.add(0.5 * this.velocity.x * dt, 0.5 * this.velocity.y * dt);
    this.velocity.add(this.acceleration.x * dt, this.acceleration.y * dt);
    this.position.add(0.5 * this.velocity.x * dt, 0.5 * this.velocity.y * dt); 
  }
  
  separate(boids, nBoids){
    let desiredSeparationDist = 20;
    
    for(let i =0; i < nBoids; i++){
      let otherBoid = boids[i];
      
      if (this == otherBoid){
        continue;
      }
      
      let distance = p5.Vector.dist(this.position, otherBoid.position);
      let sum = p.createVector();
      let nCloseBoids = 0;
      
      if (distance < desiredSeparationDist){ // get away
        let awayVector = this.position.copy().sub(otherBoid.position);
        awayVector.setMag(1);
        
        sum.add(awayVector);
        nCloseBoids++;
      }
      
      if (nCloseBoids > 0){
        sum.setMag(Boid.desiredSepSpeed);

        let steeringForce = sum.sub(this.velocity);
        steeringForce.setMag(Boid.sepForceMag);

        return steeringForce;
      }
    }
    
    return p.createVector(0,0);
  }

  seek(target){
    let desiredVel = target.copy().sub(this.position);
    desiredVel.setMag(Boid.desiredSeekSpeed);
    
    let steeringForce = desiredVel.sub(this.velocity);
    steeringForce.setMag(Boid.seekForceMag);
    
    return steeringForce;
  }

  steer(target, boids, nBoids){
    let sepForce = this.separate(boids, nBoids);
    let seekForce = this.seek(target);
    
    this.acceleration = sepForce.add(seekForce);
  }
}

const boids = [];
const nBoids = 400;

            p.setup = function() {
                p.angleMode(p.DEGREES);
                p.createCanvas(400, 400);
                
                p.fill("teal");
                
                for(let x = 0; x < 20; x++){
                    for(let y = 0; y < 20; y++){
                    let newBoid = new Boid();

                    newBoid.position = p.createVector(5 + x*15, 5 + y*15);
                    
                    boids.push(newBoid);
                    }
                }
            }

            p.draw = function() {
                p.background(220);
                let mouseVector = p.createVector(p.mouseX, p.mouseY);
                
                for(let i = 0; i < nBoids; i++){
                    boids[i].steer(mouseVector, boids, nBoids);
                    //console.log(boids[i].acceleration);
                    
                    boids[i].updatePhysics(p.deltaTime*0.001);
                    boids[i].drawBoid();
                }
            }
        }

        // Create p5 instance in the container
        let container = document.getElementById('p5-container');
        sketchInstance = new p5(sketch, container);
    </script>
</body>
</html>
